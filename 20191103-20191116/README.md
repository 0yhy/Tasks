> * 书：
>
>   * 红宝书 8-15， 23 章（重点： 8 10 11 12 13 23）
>
> * 概念：
>
>   * 浏览器缓存如何实现？前后端如何配合？
>
>   * 防抖和节流
>
> * demo：
>
>   * 实现`js`中的new操作（你实现的命名为NEW）
>
>   * 实现JS方法：call apply bind（CALL，APPLY，BIND）
>
>   * 防抖、节流辅助函数
>
>   * `leetcode`见底👇



## new操作符

**`new` 运算符**创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。**`new`** 关键字会进行如下的操作：

MDN:

1. 创建一个空的简单JavaScript对象（即`{}`）；
2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；
3. 将步骤1新创建的对象作为`this`的上下文 ；
4. 如果该函数没有返回对象，则返回`this`。

红宝书：

1. 创建一个新对象
2. 将构造函数的作用域赋给新对象（因此`this`指向了新对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象



## apply()方法

 **`apply()`** 方法调用一个具有给定`this`值的函数，以及作为一个数组（或类似数组对象）提供的参数。 

**当某一函数调用`apply()`时做了什么?**

1. 函数`this`的指向变了
2. 函数执行了

**怎样让函数`this`的指向改变？**

```javascript
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
};
```

试想当调用`apply()`的时候， 把foo对象改造如下：

```jsx
var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
```

这个时候`this`就指向了 `foo`

但是这样给`foo`对象本身添加了一个属性`bar`,  所以最后执行完函数，把属性删除

 **模拟步骤：**

 1.将函数设为对象的属性

 2.执行该函数

 3.删除该函数

```rust
// 第一步
foo.fn = bar
// 第二步
foo.fn()
// 第三步
delete foo.fn
```



## call()方法

和`apply()`方法实现思路基本相同

唯一的区别是：在`call()`方法中，其余的参数都必须逐个列举出来



## bind()方法

`bind()`方法创建一个新的函数，在`bind()`被调用时，这个新函数的`this`被`bind()`的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。

**与`apply()`、`call()`方法的区别：**

* 不会立即调用，其返回值为一个函数

* 返回的函数可以作为**构造函数**使用

  当一个绑定函数是用来构建一个值的，原来提供的 `this` 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。 

**返回值：**

​	返回一个原函数的拷贝，并拥有指定的**`this`**值和初始参数 

