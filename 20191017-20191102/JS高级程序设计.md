[TOC]

> 有点懵逼
>
> p35 Object类型 在讲啥？我是谁我在哪/xk
>
> p79 垃圾收集

# JavaScript高级程序设计

## 1. JavaScript简介

### 1.2 JavaScript实现

* JavaScript组成部分

  * 核心：ECMAScript
  * 文档对象模型
  * 浏览器对象模型

* 文档对象模型：提供访问和操作网页内容的方法和接口

  * DOM将整个页面映射为一个**多层节点结构**

* 浏览器对象模型：提供与浏览器交互的方法和接口

  * 支持可以**访问和操作浏览器窗口的**浏览器对象模型


## 3. 基本概念

### 3.1 语法

* 标识符
  * 第一个字符：字母、下划线、`$`
  * 其他字符：字母、下划线、`$`、数字
  * 命名采用**小驼峰**命名
* 严格模式
  * 在整个脚本启用：在顶部添加`"use strict"`
  * 在函数内启用：在函数内添加`"use strict"`
* 语句
  * 即使控制语句中只有一条语句，也最好使用代码块

### 3.2 关键字与保留字

* 关键字
  * 表示控制语句的开始或结束
  * 执行特定操作
* 保留字
  * 将来可能被用作关键字的词语

关键字和保留字不能作为标识符，最好也不要作为属性名

### 3.4 数据类型

* Undefined类型
  * 只有一个值`undefined`
  * 在使用`var`声明变量但未初始化，那么其值为`undefined`
* Null
  * 只有一个值`null`
  * 空对象指针
    * `undefined`值实际上是派生自`null`值的，因此`console.log(null == undefined)`的结果为`true`

> ————————怎样区别理解`null`与`undefined`————————
>
> 将`null`理解为**没有值，不应该有值**；将`undefined`理解为**缺少值 ，缺省值**
>
> `null`转化数值时为0，`undefined`转化数值时为`NaN`

* Boolean类型

  * 两个字面值：`true`和`false`

* Number类型

  * 字面值

    * 十进制字面值
    * 八进制字面值：前面加`0`
    * 十六进制字面值：前面加`0x`

  * 浮点数值

    * 浮点数值的最高精度为17位小数，但其在进行算术计算时精度远不如整数

      如`0.1+0.2`的实际结果是`0.30000000000000004`，因此无法测试特定的浮点数值

    > ——————————————注意——————————————
    >
    > 基于`IEEE745`数值的浮点计算都会产生舍入误差的问题

  * 数值范围

    * 最大值：`Number.MAX_VALUE`
    * 最小值：`Number.MIN_VALUE`
    * 超出范围：自动转化为`Infinity`或`-Infinity`
    * 判断是否超出范围：`isFinite()`

  * NaN

    * Not a Number

    * 任何涉及到`NaN`的操作都会返回`NaN`

    * 任何值都不与`NaN`相等，包括其本身

    * 是否不是数值：`isNaN()`

      * 该函数会尝试将参数转化为数值
      * 如果可以转换，返回`false`；否则返回`true`

      ```javascript
      console.log(isNaN("1027"))		//false
      console.log(isNaN("hello"))		//true
      console.log(isNaN(false))		//false
      ```

  * 数值转换

    * `Number()`
      * `null`返回值为0
      * `undefined`返回值为`NaN`
      * 字符串
        * 忽略前导0
        * 包含有效的十六进制格式，转换成相应大小的十进制整数
        * 空串转换为0
        * 非上述，转换为`NaN`
    * `parseInt(num, decimal)`   <!--num为待转换的数字，decimal为转换时使用的进制数-->
      * 省略第二个参数时：
        * 将字符串解析成整数
        * 从字符串第一位开始找到第一个非空格字符
        * 如果第一个非空格字符为数字，则继续往后解析直到下一个字符不为数字
        * 如果第一个非空格字符不为数字或不存在第一个字符（空串），返回`NaN`
        * `0`开头且合法的八进制字符串会当作八进制数解析（ECMAScript）
          * ECMAScript3可以解析八进制值
          * ECMAScript5不具备解析八进制值的能力，因此会忽略前导0
        * `0x`开头且合法的十六进制字符串会当作十六进制解析
    * `parseFloat()`
      * 将字符串解析成浮点数
      * 从字符串第一位开始找到第一个非空格字符
      * 如果第一个非空格字符且不为0，则继续往后解析直到下一个字符不为小数点或数字
      * 只有第一个小数点是有效的
      * 只解析十进制字符串，因此`0x`开头的字符串会被解析成0
      * 结果可被解析为整数，则返回整数

* String类型

  * ECMAScript中，**字符串的值是不可变的**。因此要改变某个变量保存的字符串，首先要销毁原来的字符串，然后用另一个包含新值得字符串填充该变量
  * 字符串转换
    * `toString(decimal)`方法
      * 参数`decimal`可选，表示转换的输出数值的基数。参数为空时，输出数值的基数为`0`
      * `null`、`undefined`值没有这个方法
    * `String()`函数
      * 如果待转换值含有`toString()`方法，则使用该方法
      * 如果是`null`，返回`"null"`
      * 如果是`undefined`，返回`"undefined"`

### 3.5 操作符

#### 一元操作符

只能操作一个值的操作符

* 递增/递减操作符

  * 适用于**任何值**

    * 对于字符串，使用`Number()`转换；

      若合法，字符串变量变为数字值再`+1`，得到结果为数字值

      若不合法，字符串变量变为数值变量`NaN`

    * 对于布尔值：

      `true`变为`1`再`+1`；`false`变为`0`再`+1`

    * 对于对象：

      先调用`valueOf()`方法再对该值应用上述规则

* 一元加和一元减操作符

#### 位操作符

按照内存中表示数值的位来操作数值

对于非数值应用位操作符，先**使用Number()**转化成数值，再进行操作，鸡国为数值

* 按位非：求反码`~`
* 按位与：`&`
* 按位或：`|`
* 按位异或：`^`
* 按位左移：`<<`，不影响符号位
* 有符号右移：`>>`
  * 符号位不移动
  * **使用符号位的值**填充空位
* 无符号右移：`>>>`
  * 正数：与有符号右移结果相同
  * 负数：无符号右移会**将负数的二进制码当成正数的二进制码**，因此得到的结果非常大

#### 布尔操作符 

* 逻辑非：`!`

* 逻辑与：`&&`

  逻辑与适用于**任何类型**的操作数。在**有一个操作数不是布尔数**的情况下，返回值不一定是布尔值

  | 第一个操作数              | 第二个操作数 | 返回结果     |
  | ------------------------- | ------------ | ------------ |
  | 求值结果为`false`的操作数 | 任意值       | 第一个操作数 |
  | 对象                      | 任意值       | 第二个操作数 |
  | `null`                    | 任意值       | `null`       |
  | `NaN`                     | 任意值       | `NaN`        |
  | `undefined`               | 任意值       | `undefined`  |

  逻辑与操作属于**短路操作**，即如果第一个操作数能决定结果，那么不会再对第二个操作数进行求值

* 逻辑或：`||`

  逻辑或适用于**任何类型**的操作数。在**有一个操作数不是布尔数**的情况下，返回值不一定是布尔值

  | 第一个操作数              | 第二个操作数 | 返回结果     |
  | ------------------------- | ------------ | ------------ |
  | 求值结果为`false`的操作数 | 任意值       | 第二个操作数 |
  | 对象                      | 任意值       | 第一个操作数 |
  | `null`                    | 任意值       | 第二个操作数 |
  | `NaN`                     | 任意值       | 第二个操作数 |
  | `undefined`               | 任意值       | 第二个操作数 |

#### 乘性操作符

如果有一个操作数不是数值，那么会先使用`Number()`将其转换为数值

* 乘法
* 除法
* 求模

#### 加性操作符

* 加法<!--这是我自己总结的，不知道对不对-->：结果为数值或字符串

  * 如果两个操作数**都不是字符串且不是对象**：则将两个操作数都转为数值，然后进行正常的加法操作

  * 否则：对两个操作数根据类型调用`toString()`方法或`String()`函数

    * 对象、布尔值、数值`toString()`方法
    * `null`、`undefined`使用`String()`函数

    然后再将两个操作数拼接起来，返回结果

* 减法：结果为数值
  * 如果两个操作数**都不是对象**：先在后台调用`Number()`函数将其转换为数值，进行减法操作
  * 如果有一个操作数是对象：
    * 有`valueOf()`方法：获取该对象的数值后进行减法
    * 没有`valueOf()`方法：调用`toString()`方法并将得到的字符串转换为数值，再进行减法

#### 关系操作符

* 如果两个操作数**都为字符串**：比较两个字符串对应的字符编码值
* 否则：将两个操作数按照规则转化为数值，再进行比较

#### 相等操作符

##### 相等和不相等`==`

先转换，再比较（也叫强制转型）

| 第一个操作数 | 第二个操作数 | 值                              |
| ------------ | ------------ | ------------------------------- |
| null         | undefined    | true                            |
| null         | 0            | false                           |
| undefined    | 0            | false                           |
| NaN          | NaN          | false                           |
| NaN          | 任意值       | false                           |
| false        | 0            | true                            |
| true         | 1            | true                            |
| 字符串       | 数值         | 字符串变为数值后比较            |
| 布尔值       | 任意值       | 变为数值后比较                  |
| 对象         | 对象         | 比较是否**指向**同一对象        |
| 对象         | 非对象       | 对对象调用`valueOf()`方法后比较 |

##### 全等和不全等`===`

不转换，直接比较

注意：`undefined === null`的结果为`false`



#### 条件操作符

`variable = boolean_expression ? true_value : false_value`

#### 赋值操作符

将右侧的值赋给左侧的变量

#### 逗号操作符

* 在一条语句中执行多个操作
* 在赋值时，逗号表达式**总会返回表达式中的最后一项**

```JavaScript
var num = (5, 1, 3, 0, 7) 	//num的值为7
```



### 3.6 语句

#### `for-in`语句

精准的**迭代语句，用来枚举对象的属性**

`ECMAScript`对象的属性没有顺序，因此通过该循环输出的属性名的**顺序是不可预测的**

```JavaScript
var a = {"name":"shaw","age":19};
for (i in a) {
    console.log(i);
}
//name
//age
```

#### `label`语句

`label: statement`

```JavaScript
start: for (let i = 0; i < 10; i++) {
    console.log(i);
}
```

`label`语句可以在**代码中添加标签**，以便将来使用

#### `break`和`continue`语句

`break`：立即退出循环，强制执行循环后的语句

`continue`：退出当前层循环，从循环顶部继续执行

**与`label`联合使用**

```JavaScript
mark:
for (var i = 0; i < 10; i++) {
    for (var j = 0; j < 10; j++) {
        if(i == 5 && j == 5) {
            break mark;
        }
        num++;
    }
}
console.log(num);//55
```

#### `with`语句

* `with`语句的作用是将代码的作用域设置到一个特定的对象中

* 严格模式下不允许使用`with`语句

* 大量使用`with`语句会导致性能下降

#### `switch`语句

* 可以使用**任意数据类型**
* `case`的值不一定是常量，也可以是**变量甚至表达式**
* 比较时使用的是**全等操作符**



### 3.7 函数

`return;`语句的返回值为`undefined`

##### 理解参数

* 在`ECMAScript`中参数是用一个数组来表示的，函数接收到的永远是一个数组，而不关心数组中包含哪些参数。因此**传递进来的参数个数/数据类型都不重要**

* 在函数体内可以使用`arguments`对象来访问参数数组

  ```javascript
  function hello() {
      console.log("Hello, " + arguments[0]);
  }
  hello("Shaw");
  //Hello, Shaw
  ```

* 使用`arguments.length`可获取参数个数
* 可以设置`arguments`中元素的值，并且它的值永远**与对应命名参数的值**保持同步（严格模式下无效）
* `ECMAScript`中的所有参数传递的都是**值**，**不能通过引用传参**

##### 没有重载

* 在`ECMAScript`中**后定义的函数会覆盖先定义的函数**

> 在`ECMAScript`中没有函数签名，其函数参数是以一个包含0/多个值的数组形式传递的，因此不能重载



## 4. 变量、作用域与内存

### 4.1 基本类型和引用类型的值

* 基本类型值：`Undefined`、`Null`、`Number`、`Boolean`、`String`

  这五种基本数据类型是按值访问的，因为可以**直接操作保存在变量中的实际的值**

* 引用类型值：保存在**内存**中的对象

  复制保存着对象的变量时：操作的是对象的引用

  为对象添加属性时：操作的是实际的对象

#### 动态的属性

只能给**引用类型值**动态地添加属性

#### 复制变量值

* 基本类型值
  * 原来的变量和新变量完全独立

* 引用类型值
  * 将存储在变量对象中的值复制一份放到为新变量分配的空间中
  * 但这个值的副本实际上是**指针**，指向存储在堆中的一个对象

#### 传递参数

**`ECMAScript`中的函数的参数都是按值传递的**

p71 详细理解为什么对象也是按值传递的

#### 检测类型

* 检测基本数据类型

  `typeof`函数检测

  注意：对象或`null`都会返回`object`

  > 为什么`null`也返回`object`，因为这是个历史遗留bug，太秀了
  >
  > 详见：<https://www.cnblogs.com/xiaoheimiaoer/p/4572558.html>

* 检测引用类型

  `instanceof`

  ~~~JavaScript
  console.log(person instanceof Object);
  console.log(a instanceof Array);
  console.log(b instanceof RegExp);
  ~~~

  判断变量是否为**给定引用类型的实例**

  > 用`instanceof`检测基本类型时返回值永远是`false`



### 4.2 执行环境及作用域

* 变量对象

  每个执行环境都有一个与之关联的变量对象，用于保存**环境中定义的变量和函数**

* 全局执行环境

  最外围的执行环境

* 环境栈

  每个函数都有自己的**执行环境**

  当**执行流**进入一个函数时，函数的环境就会被推入**环境栈**中

  当函数执行后，栈将该函数的执行环境弹出，把**控制权返回给**之前的执行环境

* 作用域链

  当代码在某一环境中执行时，会创建该环境的变量对象的**作用域链**

  作用域链用于保证当前执行环境中所有有权访问的函数和变量的**有序访问**

#### 延长作用域链

* `with`语句

  ```javascript
  function hello() {
      var extend = "hello there";
      with(extend) {
          console.log(toUpperCase());
      }
  }
  ```

  `with`语句接收`extend`对象，其变量对象被添加到了**作用域链的最顶端**

* `try-catch`语句



#### 没有块级作用域

* 声明变量

  `var`声明的变量会自动被添加到**最接近的环境**中

  没有使用`var`声明的变量会被添加到全局环境

### 4.3 垃圾收集

`JavaScript`具有**自动垃圾收集机制**，即**找出那些不再继续使用的变量，然后释放其占用的内存**。为此，垃圾收集器会按照固定的时间间隔，周期性的执行这一操作

标识无用变量的策略：

* 标记清除：

  变量进入环境，标记为”进入环境“；相应的，变量离开环境，则标记为“离开环境”

* 引用计数：

  跟踪记录每个值被引用的次数



## 5. 引用类型

对象是某个**特定引用类型**的实例，如`var person = new Object();`,

新对象使用`new`操作符，后面加一个**构造函数**来创建

### 5.1 Object类型

* 创建`Object`实例

  * **`new`操作符 + `Object()`构造函数**

  * **对象字面量表示法**

    ```javascript
    var person = {
        name : "Shaw",
        age : 19
    }
    ```

    左花括号`{`表示对象字面量的开始，因为他出现在了**表达式上下文**（expression context）中

    > 花括号出现在**表达式上下文**中，表示对象字面量的开始
    >
    > 花括号出现在**语句上下文**中，表示一个**语句块的开始**

    ```javascript
    
    ```

    使用对象字面量表示法时，如果留空花括号，则相当于`new Object()`

* 访问对象属性

  * 点表示法：`person.name`
  * 方括号表示法：
    * `person["name"]`
    * `person["first name"]`（这种会导致语法错误的属性名不能用点表示法访问） 

  <!--方括号表示法的优点是：可以通过变量来访问属性-->

### 5.2 Array类型

* 创建数组

  * **`Array()`构造函数**

    `var colors = new Array()`

    * 构造函数中可以传项目的数量

      `var colors = new Array(10)`

    * 构造函数中可以传数组中包含的项

      `var colors = new Array("blue", "red", "green")`

    * 使用构造函数可以省略`new`操作符

      `var colors = Array(3)`

      `var colors = Array("blue", "green")`

  * **数组字面量表示法**

    `var colors = ["red", "blue", "white"]`

* 访问数组元素
  * 如果索引超过了数组大小，那么数组就会**自动增加到该索引值+1的长度**
  * 数组的`length`**不是只读**的，可以通过修改`length`修改数组的大小

* 检测数组

  * `instance of`操作符

    问题：**假设只有一个全局执行环境**；当网页包含多个框架时，那么存在2+个全局执行环境，则存在**两个以上不同版本的`Array`构造函数

  * `Array.isArray()`方法

    `ECMAScript5`新增方法，不会管它是在哪个全局执行环境中创建

* 转换方法

  * `valueOf()`：返回原数组
  * `toString()`：返回数组中每个值的字符串形式拼接而成的、以逗号分隔的 字符串
  * `alert(Array)`：`alert`接受字符串，因此会在后台**调用`toString()`方法
  * `toLocaleString()`：创建一个数组值的以逗号分隔的字符串

